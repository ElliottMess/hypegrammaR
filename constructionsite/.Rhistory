}
}
# load dependencies
.load_dependencies<- function(dependencies){
sapply(dependencies, require, character.only = TRUE)
return(dependencies)
}
.dependencies<-c("dplyr","ggplot2","ggthemes","reshape2","questionr")
.install_dependencies(.dependencies)
.install_reachR(reinstall_if_exists = F)
.load_dependencies(c(.dependencies,"reachR"))
dependencies_spatial<-c("rgdal","raster","RgoogleMaps","ggmap","gstat")
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T, branch = "master")
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
require(dplyr)
library(reachR)
require(survey)
getwd()
# load input
read.csv.auto.sep<-function(file){
L<-readLines(file, n = 1)
numfields<- L %>% strsplit(";") %>% unlist %>% length
if (numfields == 1) read.csv(file) else read.csv2(file)
}
data<-read.csv.auto.sep(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv")
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
debug(load_questionnaire)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
undebug(load_questionnaire)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
data.dependent.var = "resp_gender"
independent.var = "settlement"
hypothesis.type="difference_in_groups"
#das könnte auch eleganter gehen mit funktion über x und jeder variable in x einen Type dazu machen
find.data.types <- function(data.dependent.var, independent.var = NULL) {
if(question_is_categorical(data.dependent.var) == T){
data.type.dep = "categorical"
}
if(question_is_numeric(data.dependent.var) == T){
data.type.dep = "numeric"
}
if(question_is_categorical(independent.var) == T){
data.type.indep = "categorical"
}
if(question_is_numeric(independent.var) == T){
data.type.indep = "numeric"
}
variable.types <- paste(data.type.dep, data.type.indep, sep="_")
return(variable.types)
}
find.data.types(data.dependent.var, independent.var)
debug(question_is_numeric)
find.data.types(data.dependent.var, independent.var)
#' load_questionnaire
#'
#' @param questions.file file name of a csv file containing the kobo form's question sheet
#' @param choices.file file name of a csv file containing the kobo form's choices sheet
#' @return list of questions and choices, sorted to match. to data columns.
#' @seealso \code{\link{load_data()}, \link{load_samplingframe}}
#' @export
#' @examples
#'
load_questionnaire<-function(data,
questions.file,
choices.file,
choices.label.column.to.use="label..English"){
# generic function to replace values in a vector based on a lookup table
replace_with_lookup_table<-function(x,y){
x2 <- y[match(x, y[,1]),2]
dim(x2) <- dim(x)
x2
}
# load files
questions<-read.csv(questions.file,stringsAsFactors = F, header = T)
choices<-read.csv(choices.file,stringsAsFactors = F, header = T)
# harmonise data column references
questions$name <- reachR:::to_alphanumeric_lowercase(questions$name)
names(choices) <- reachR:::to_alphanumeric_lowercase(names(choices))
names(data) <- reachR:::to_alphanumeric_lowercase(names(data))
choices.label.column.to.use <- reachR:::to_alphanumeric_lowercase(choices.label.column.to.use)
# sanitise
names(questions)
reachR:::insure.string.is.column.header(questions, "type")
reachR:::insure.string.is.column.header(questions, "name")
reachR:::insure.string.is.column.header(choices, choices.label.column.to.use)
reachR:::insure.string.is.column.header(choices, "list.name")
# get data column names
data_colnames<-names(data); data_colnames
# this changes the questionnaire questions and choices to fit the data columns, with empty entries for data columns that don't appear in the questionnaire.
questions<- questions[match(data_colnames, questions$name),]
choices_per_data_column<-questions$type %>% as.character %>% strsplit(" ") %>% lapply(unlist)%>% lapply(function(x){
x %>% lapply(function(y){
grep(y,choices$list_name,value=F)
}
) %>% unlist
}) %>% lapply(hasdata) %>% lapply(function(x){
choices[x,]
})
names(choices_per_data_column)<- data_colnames
# make functions that need questionnaire
assignInNamespace(x = "question_get_choice_labels_internal", ns="reachR", value = function(responses,variable.name){
labels<-replace_with_lookup_table(
responses,
# MAKE LABEL COLUMN A PARAMETER!!!
cbind(as.character(choices_per_data_column[[variable.name]]$name),as.character(choices_per_data_column[[variable.name]]$label..datamerge))
)
# fix those that were not found to go back to original NA
labels[is.na(labels)]<-responses[is.na(labels)]
labels
})
assignInNamespace(x = "question_is_numeric_internal", ns="reachR", value =function(question.name){
if(is.null(question.name)){return(FALSE)}
if(is.na(question.name){return(FALSE)})
if(question.name==""){return(FALSE)}
qid<-which(questions$name==question.name)
if(length(qid)==0){return(FALSE)}
if(length(c(grep("integer",questions$type[qid]),grep("decimal"),questions$typep[qid]))>0){return(TRUE)}
return(FALSE)
})
assignInNamespace(x = "question_is_select_one_internal", ns="reachR", value =function(question.name){
if(is.null(question.name)){return(FALSE)}
if(is.na(question.name){return(FALSE)})
if(question.name==""){return(FALSE)}
if(!(question.name %in% questions$name)){return(FALSE)}
qid<-which(questions$name==question.name)
if(length(grep("select_one",questions$type[qid]))>0){return(TRUE)}
return(FALSE)
})
assignInNamespace(x = "question_is_select_multiple_internal", ns="reachR", value = function(question.name){
if(is.null(question.name)){return(FALSE)}
if(is.na(question.name){return(FALSE)})
if(question.name==""){return(FALSE)}
if(!(question.name %in% questions$name)){return(FALSE)}
qid<-which(questions$name==question.name)
if(length(grep("select_multiple",questions$type[qid]))>0){return(TRUE)}
return(FALSE)
})
assignInNamespace(x = "question_is_categorical_internal", ns="reachR", value = function(question.name){
if(is.null(question.name)){return(FALSE)}
if(is.na(question.name){return(FALSE)})
if(question.name==""){return(FALSE)}
return(question_is_select_one(question.name) | question_is_select_multiple(question.name))
})
message("you can now use \n 'get_choice_labels():'change answers to their labels \n question_is_categorical() \n question_is_categorical()\n question_is_select_one() \n question_is_select_multiple()")
return(list(questions=questions,choices=choices,choices_per_variable=choices_per_data_column))
}
question_get_choice_labels_internal<-function(responses,variable.name){
stop("you must successfully run load_questionnaire() first")
}
question_is_numeric_internal<-function(question.name){
stop("you must successfully run load_questionnaire() first")
}
question_is_select_one_internal<-function(question.name){
stop("you must successfully run load_questionnaire() first")
}
question_is_select_multiple_internal<-function(question.name){
stop("you must successfully run load_questionnaire() first")
}
question_is_categorical_internal<-function(question.name){
stop("you must successfully run load_questionnaire() first")
}
#' question_get_choice_labels
#'
#' @param responses a vector of responses
#' @param variable.name the column name of the corresponding variable
#' @return vector of labels corresponding to the responses vector. If no corresponding label is found, return the original value
#' @seealso
#' @export
#' @examples
#'
question_get_choice_labels<-function(responses,variable.name){
question_get_choice_labels_internal(responses,variable.name)
}
#' question_is_numeric
#'
#' @param question.name the name of a data column header
#' @return TRUE if the question is of type integer or decimal
#' @seealso
#' @export
#' @examples
#'
question_is_numeric<-function(question.name){
question_is_numeric_internal(question.name)
}
#' question_is_select_one
#'
#' @param question.name the name of a data column header
#' @return TRUE if the question is of type select_one
#' @seealso
#' @export
#' @examples
#'
question_is_select_one<-function(question.name){
question_is_select_one_internal(question.name)
}
#' question_is_select_multiple
#'
#' @param question.name the name of a data column header
#' @return TRUE if the question is of type select_multiple
#' @seealso
#' @export
#' @examples
#'
question_is_select_multiple<-function(question.name){
question_is_select_multiple_internal(question.name)
}
#' question_is_categorical
#'
#' @param question.name the name of a data column header
#' @return TRUE if the question is of type select_one or select_multiple
#' @seealso
#' @export
#' @examples
#'
question_is_categorical<-function(question.name){
question_is_categorical_internal(question.name)
}
#das könnte auch eleganter gehen mit funktion über x und jeder variable in x einen Type dazu machen
find.data.types <- function(data.dependent.var, independent.var = NULL) {
if(question_is_categorical(data.dependent.var) == T){
data.type.dep = "categorical"
}
if(question_is_numeric(data.dependent.var) == T){
data.type.dep = "numeric"
}
if(question_is_categorical(independent.var) == T){
data.type.indep = "categorical"
}
if(is.null(independent.var)
question_is_numeric(independent.var) == T){
data.type.indep = "numeric"
}
variable.types <- paste(data.type.dep, data.type.indep, sep="_")
return(variable.types)
}
rm(list = ls())
source("./dependencies.R")
data<-read.csv.auto.sep(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv")
# load input
read.csv.auto.sep<-function(file){
L<-readLines(file, n = 1)
numfields<- L %>% strsplit(";") %>% unlist %>% length
if (numfields == 1) read.csv(file) else read.csv2(file)
}
data<-read.csv.auto.sep(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv")
reachR:::load_questionnaire
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T, branch = "master")
hypothesis_test_one_sample_z_num <- function(data.dependent.var, crit, design, data = data) {
svyttest(data.dependent.var~1, null.value = crit, design = design)
}
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T, branch = "master")
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls())
require(dplyr)
library(reachR)
require(survey)
#load function to treat csv and csv2 equally
read.csv.auto.sep<-function(file){
L<-readLines(file, n = 1)
numfields<- L %>% strsplit(";") %>% unlist %>% length
if (numfields == 1) read.csv(file) else read.csv2(file)
}
#load function to treat csv and csv2 equally
read.csv.auto.sep<-function(file){
L<-readLines(file, n = 1)
numfields<- L %>% strsplit(";") %>% unlist %>% length
if (numfields == 1) read.csv(file) else read.csv2(file)
}
#load input
data<-read.csv.auto.sep(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv")
#load sampling frame
samplingframe<-read.csv.auto.sep(file = "sf.csv",header = T,stringsAsFactors = F)
#load sampling frame
samplingframe<-read.csv.auto.sep(file = "sf.csv")
populations<-load_samplingframe("./sf.csv",
sampling.frame.population.column="Population",
sampling.frame.stratum.column = "Camp_",
data.stratum.column = "overview.camp_name", return.stratum.populations = T)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
reachR:::load_questionnaire
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
data.dependent.var = "resp_gender"
independent.var = "settlement"
hypothesis.type="difference_in_groups"
#das könnte auch eleganter gehen mit funktion über x und jeder variable in x einen Type dazu machen
find.data.types <- function(data.dependent.var, independent.var = NULL) {
if(question_is_categorical(data.dependent.var) == T){
data.type.dep = "categorical"
}
if(question_is_numeric(data.dependent.var) == T){
data.type.dep = "numeric"
}
if(question_is_categorical(independent.var) == T){
data.type.indep = "categorical"
}
if(question_is_numeric(independent.var) == T){
data.type.indep = "numeric"
}
variable.types <- paste(data.type.dep, data.type.indep, sep="_")
return(variable.types)
}
find.data.types(data.dependent.var, independent.var)
reachR:::question_is_numeric_internal()
reachR:::question_is_numeric_internal
reachR:::question_is_numeric
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T, branch = "master")
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
require(dplyr)
library(reachR)
require(survey)
reachR:::load_questionnaire
#load input
data<-read.csv.auto.sep(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv")
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
find.data.types(data.dependent.var, independent.var)
#das könnte auch eleganter gehen mit funktion über x und jeder variable in x einen Type dazu machen
find.data.types <- function(data.dependent.var, independent.var = NULL) {
data.type.dep = c()
data.type.indep = c()
if(question_is_categorical(data.dependent.var) == T){
data.type.dep = "categorical"
}
if(question_is_numeric(data.dependent.var) == T){
data.type.dep = "numeric"
}
if(question_is_categorical(independent.var) == T){
data.type.indep = "categorical"
}
if(question_is_numeric(independent.var) == T){
data.type.indep = "numeric"
}
variable.types <- paste(data.type.dep, data.type.indep, sep="_")
return(variable.types)
}
data.type.dep <- c()
data.type.dep = c()
data.type.indep = c()
#das könnte auch eleganter gehen mit funktion über x und jeder variable in x einen Type dazu machen
find.data.types <- function(data.dependent.var, independent.var = NULL) {
data.type.dep = c()
data.type.indep = c()
if(question_is_categorical(data.dependent.var) == T){
data.type.dep = "categorical"
}
if(question_is_numeric(data.dependent.var) == T){
data.type.dep = "numeric"
}
if(question_is_categorical(independent.var) == T){
data.type.indep = "categorical"
}
if(question_is_numeric(independent.var) == T){
data.type.indep = "numeric"
}
variable.types <- paste(data.type.dep, data.type.indep, sep="_")
return(variable.types)
}
find.data.types(data.dependent.var, independent.var)
find.data.types(data.dependent.var)
find.data.types(data.dependent.var, independent.var)
find.data.types(data.dependent.var, independent.var)
question_is_categorical(data.dependent.var)
get(data.dependent.var)
get(independent.var)
View(questionnaire)
questionnaire[[1]]
View(questionnaire)
questionnaire[["questions"$name]]
questions <- questionnaire[[1]]
questions$name
data.dependent.var = "is.this.an.idp.settlement."
#das könnte auch eleganter gehen mit funktion über x und jeder variable in x einen Type dazu machen
find.data.types <- function(data.dependent.var, independent.var = NULL) {
data.type.dep = c()
data.type.indep = c()
if(question_is_categorical(data.dependent.var) == T){
data.type.dep = "categorical"
}
if(question_is_numeric(data.dependent.var) == T){
data.type.dep = "numeric"
}
if(question_is_categorical(independent.var) == T){
data.type.indep = "categorical"
}
if(question_is_numeric(independent.var) == T){
data.type.indep = "numeric"
}
variable.types <- paste(data.type.dep, data.type.indep, sep="_")
return(variable.types)
}
find.data.types(data.dependent.var, independent.var)
questions$name
#choose test
#still need to add sampling strategy = in here, but for now this package deals with simple random, stratified and cluster in the same way
#and the others not at all
choose.test <- function(hypothesis.type, variable.types, crit = NULL, paired = NULL){
typestring <- paste("TYPE",hypothesis.type,variable.types, paired, sep="_")
# typestring="TYPE_direct_reporting_simple_random_numeric"
TYPE_group_difference_categorical_categorical_ <- hypothesis_test_chisquare
# TYPE_group_difference_numeric_categorical <- hypothesis_test_difference_in_means
# TYPE_limit_numeric <- hypothesis_test_one_sample_z_num
# TYPE_limit_categorical <- hypothesis_test_one_sample_z_cat
# TYPE_direct_reporting_numeric <- confidence_intervals_num
# TYPE_direct_reporting_categorical <- confidence_intervals_cat
# TYPE_change_over_time_numeric <- hypothesis_test_difference_in_means #paired or unpaires
# TYPE_change_over_time_categorical <- hypothesis_test_chisquare
# TYPE_correlation_numeric_numeric <- hypothesis_test_regression
# TYPE_correlation_categorical_numeric <- hypothesis_test_logistic_regression #warn: categorical variable must be binary (ensure)
#
return(get(typestring))
}
choose.test(hypothesis.type = hypothesis.type, variable.types = variable.types)
data.dependent.var
find.data.types(data.dependent.var, independent.var)
variable.type<-find.data.types(data.dependent.var, independent.var)
variable.type
choose.test(hypothesis.type = hypothesis.type, variable.types)
choose.test(hypothesis.type = hypothesis.type, variable.types = variable.type)
hypothesis_test_chisquare <- function(dependentvar, independent, design, data = data) {
Chisq <- svychisq(~ dependentvar + independent, design, na.rm = TRUE)
# Groups <-
namesA <- unique(dependentvar)
namesB <- unique(independent)
b <- ftable(a, rownames = namesA, namesB)
return(b)
}
choose.test(hypothesis.type = hypothesis.type, variable.types = variable.type)
choose.test <- function(hypothesis.type, variable.types, crit = NULL, paired = NULL){
typestring <- paste(c("TYPE",hypothesis.type,variable.types, paired), collapse = "_")
# typestring="TYPE_direct_reporting_simple_random_numeric"
TYPE_group_difference_categorical_categorical_ <- hypothesis_test_chisquare
# TYPE_group_difference_numeric_categorical <- hypothesis_test_difference_in_means
# TYPE_limit_numeric <- hypothesis_test_one_sample_z_num
# TYPE_limit_categorical <- hypothesis_test_one_sample_z_cat
# TYPE_direct_reporting_numeric <- confidence_intervals_num
# TYPE_direct_reporting_categorical <- confidence_intervals_cat
# TYPE_change_over_time_numeric <- hypothesis_test_difference_in_means #paired or unpaires
# TYPE_change_over_time_categorical <- hypothesis_test_chisquare
# TYPE_correlation_numeric_numeric <- hypothesis_test_regression
# TYPE_correlation_categorical_numeric <- hypothesis_test_logistic_regression #warn: categorical variable must be binary (ensure)
#
return(get(typestring))
}
choose.test(hypothesis.type = hypothesis.type, variable.types = variable.type)
choose.test <- function(hypothesis.type, variable.types, crit = NULL, paired = NULL){
typestring <- paste(c("TYPE",hypothesis.type,variable.types, paired), collapse = "_")
# typestring="TYPE_direct_reporting_simple_random_numeric"
TYPE_group_difference_categorical_categorical <- hypothesis_test_chisquare
# TYPE_group_difference_numeric_categorical <- hypothesis_test_difference_in_means
# TYPE_limit_numeric <- hypothesis_test_one_sample_z_num
# TYPE_limit_categorical <- hypothesis_test_one_sample_z_cat
# TYPE_direct_reporting_numeric <- confidence_intervals_num
# TYPE_direct_reporting_categorical <- confidence_intervals_cat
# TYPE_change_over_time_numeric <- hypothesis_test_difference_in_means #paired or unpaires
# TYPE_change_over_time_categorical <- hypothesis_test_chisquare
# TYPE_correlation_numeric_numeric <- hypothesis_test_regression
# TYPE_correlation_categorical_numeric <- hypothesis_test_logistic_regression #warn: categorical variable must be binary (ensure)
#
return(get(typestring))
}
choose.test(hypothesis.type = hypothesis.type, variable.types = variable.type)
hypothesis.type="group_difference"
choose.test <- function(hypothesis.type, variable.types, crit = NULL, paired = NULL){
typestring <- paste(c("TYPE",hypothesis.type,variable.types, paired), collapse = "_")
# typestring="TYPE_direct_reporting_simple_random_numeric"
TYPE_group_difference_categorical_categorical <- hypothesis_test_chisquare
# TYPE_group_difference_numeric_categorical <- hypothesis_test_difference_in_means
# TYPE_limit_numeric <- hypothesis_test_one_sample_z_num
# TYPE_limit_categorical <- hypothesis_test_one_sample_z_cat
# TYPE_direct_reporting_numeric <- confidence_intervals_num
# TYPE_direct_reporting_categorical <- confidence_intervals_cat
# TYPE_change_over_time_numeric <- hypothesis_test_difference_in_means #paired or unpaires
# TYPE_change_over_time_categorical <- hypothesis_test_chisquare
# TYPE_correlation_numeric_numeric <- hypothesis_test_regression
# TYPE_correlation_categorical_numeric <- hypothesis_test_logistic_regression #warn: categorical variable must be binary (ensure)
#
return(get(typestring))
}
choose.test(hypothesis.type = hypothesis.type, variable.types = variable.type)
choose.test(hypothesis.type = hypothesis.type, variable.types = variable.type)
stat.test <- choose.test(hypothesis.type = hypothesis.type, variable.types = variable.type)
design <- svydesign(ids =~1,
strata = strata_of(data),
weights = variable_weights %>% as.vector,
data = data)
# select methods
variable_weights <- reachR:::weights_of(data)
populations<-load_samplingframe("./sf.csv",
sampling.frame.population.column="Population",
sampling.frame.stratum.column = "Camp_",
data.stratum.column = "overview.camp_name", return.stratum.populations = T)
design <- svydesign(ids =~1,
strata = strata_of(data),
weights = variable_weights %>% as.vector,
data = data)
# select methods
variable_weights <- reachR:::weights_of(data)
