}
hypothesis_test_functions<-list()
# prefill all valid cases with 'not implemented' errors:
hypothesis_test_functions<-lapply(list_all_cases(implemented_only = F),function(x){
hypothesis_test_functions[[x]]<-function(...){stop(paste("not yet implemented: hypothesis test for case",x))}
return(NULL)
})
hypothesis_test_functions
# prefill all valid cases with 'not implemented' errors:
hypothesis_test_functions<-lapply(list_all_cases(implemented_only = F),function(x){
function(...){stop(paste("not yet implemented: hypothesis test for case",x))}
})
hypothesis_test_functions
names(hypothesis_test_functions)<-list_all_cases(implemented_only = F)
hypothesis_test_functions
# add implemented cases:
hypothesis_test_functions[["CASE_group_difference_categorical_categorical"]] <- hypothesis_test_chisquared
hypothesis_test_functions
map_to_hypothesis_test <- function(case) {
hypothesis_test_functions<-list()
# prefill all valid cases with 'not implemented' errors:
hypothesis_test_functions<-lapply(list_all_cases(implemented_only = F),function(x){
function(...){stop(paste("not yet implemented: hypothesis test for case",x))}
})
names(hypothesis_test_functions)<-list_all_cases(implemented_only = F)
# add implemented cases:
hypothesis_test_functions[["CASE_group_difference_categorical_categorical"]] <- hypothesis_test_chisquared
return(hypothesis_test_functions[[case]])
}
# prefill all valid cases with 'not implemented' errors:
hypothesis_test_functions<-list()
names(hypothesis_test_functions)<-list_all_cases(implemented_only = F)
hypothesis_test_functions
map_to_hypothesis_test <- function(case) {
# prefill all valid cases with 'not implemented' errors:
hypothesis_test_functions<-list()
hypothesis_test_functions<-lapply(list_all_cases(implemented_only = F),function(x){
function(...){stop(paste("not yet implemented: hypothesis test for case",x))}
})
names(hypothesis_test_functions)<-list_all_cases(implemented_only = F)
# add implemented cases:
hypothesis_test_functions[["CASE_group_difference_categorical_categorical"]] <- hypothesis_test_chisquared
return(hypothesis_test_functions[[case]])
}
map_to_hypothesis_test <- function(case) {
# prefill all valid cases with 'not implemented' errors:
hypothesis_test_functions<-list()
hypothesis_test_functions<-lapply(list_all_cases(implemented_only = F),function(x){
function(...){stop(paste("not yet implemented: hypothesis test for case",x))}
})
names(hypothesis_test_functions)<-list_all_cases(implemented_only = F)
# add implemented cases:
hypothesis_test_functions[["CASE_group_difference_categorical_categorical"]] <- hypothesis_test_chisquared
return(hypothesis_test_functions[[case]])
}
map_to_hypothesis_test <- function(case) {
# prefill all valid cases with 'not implemented' errors:
hypothesis_test_functions<-list()
hypothesis_test_functions<-lapply(list_all_cases(implemented_only = F),function(x){
function(...){stop(paste("not yet implemented: hypothesis test for case",x))}
})
names(hypothesis_test_functions)<-list_all_cases(implemented_only = F)
# add implemented cases:
hypothesis_test_functions[["CASE_group_difference_categorical_categorical"]] <- hypothesis_test_chisquared
# return function belonging to this case:
return(hypothesis_test_functions[[case]])
}
map_to_hypothesis_test <- function(case) {
# prefill all valid cases with 'not implemented' errors:
hypothesis_test_functions<-list()
hypothesis_test_functions<-lapply(list_all_cases(implemented_only = F),function(x){
function(...){stop(paste("not implemented: hypothesis test for case",x))}
})
names(hypothesis_test_functions)<-list_all_cases(implemented_only = F)
# add implemented cases:
hypothesis_test_functions[["CASE_group_difference_categorical_categorical"]] <- hypothesis_test_chisquared
# return function belonging to this case:
return(hypothesis_test_functions[[case]])
}
#################################
# map to visualisation:         #
#################################
map_to_visualisation <- function(case) {
visualisation_functions<-list()
# prefill all valid cases with 'not implemented' errors:
lapply(list_all_cases(implemented_only = F),function(x){
hypothesis_test_functions[[x]]<-case_not_implemented_error(case,"hypothesis test")
})
# add implemented cases:
visualisation_functions[["CASE_group_difference_categorical_categorical"]] <- hypothesis_test_chisquared
return(hypothesis_test_functions[[case]])
}
map_to_hypothesis_test <- function(case) {
# prefill all valid cases with 'not implemented' errors:
hypothesis_test_functions<-list()
hypothesis_test_functions<-lapply(list_all_cases(implemented_only = F),function(x){
function(...){stop(paste("not implemented: hypothesis test for case",x,".\n the geneva data unit can help!"))}
})
names(hypothesis_test_functions)<-list_all_cases(implemented_only = F)
# add implemented cases:
hypothesis_test_functions[["CASE_group_difference_categorical_categorical"]] <- hypothesis_test_chisquared
# return function belonging to this case:
return(hypothesis_test_functions[[case]])
}
####################
# SETUP
####################
# set wd to this script's folder
rm(list = ls())
this_script_path<-(dirname(rstudioapi::getActiveDocumentContext()$path))
setwd(this_script_path)
getwd()
source("./scripts/dependencies.R")
source("./scripts/analyse_indicator.R")
source("./scripts/mappings.R")
source("./scripts/summary_statistics.R")
source("./scripts/hypothesis_tests.R")
source("./scripts/visualisations.R")
map_to_hypothesis_test("CASE_group_difference_categorical_categorical")
map_to_hypothesis_test <- function(case) {
# prefill all valid cases with 'not implemented' errors:
hypothesis_test_functions<-list()
hypothesis_test_functions<-lapply(list_all_cases(implemented_only = F),function(x){
function(...){stop(paste("not implemented: hypothesis test for case",x,".\n the geneva data unit can help!"))}
})
names(hypothesis_test_functions)<-list_all_cases(implemented_only = F)
# add implemented cases:
hypothesis_test_functions[["CASE_group_difference_categorical_categorical"]] <- hypothesis_test_chisquared
# return function belonging to this case:
return(hypothesis_test_functions[[case]])
}
#################################
# map to hypothesis test  :     #
#################################
map_to_hypothesis_test("CASE_group_difference_categorical_categorical")
####################
# SETUP
####################
# set wd to this script's folder
rm(list = ls())
this_script_path<-(dirname(rstudioapi::getActiveDocumentContext()$path))
setwd(this_script_path)
getwd()
####################
# SETUP
####################
# clear wd set wd to this script's folder
rm(list = ls())
setwd(this_script_path)
getwd()
source("./scripts/dependencies.R")
this_script_path<-(dirname(rstudioapi::getActiveDocumentContext()$path))
source("./scripts/mappings.R")
source("./scripts/analyse_indicator.R")
source("./scripts/summary_statistics.R")
source("./scripts/hypothesis_tests.R")
source("./scripts/visualisations.R")
library(reachR)
#install.packages("bit64")
# library(bit64)
require(data.table)
require(survey)
options(survey.lonely.psu = "average")
# the cleaning checks will be hidden somewhere else, for now they live here
data<- load_data(file = "./data/kri_winter.csv")
populations <-load_samplingframe("./data/kri_winter_weights.csv",
sampling.frame.population.column="population",
sampling.frame.stratum.column = "group",
data.stratum.column = "group", return.stratum.populations = T)
populations
questionnaire <- load_questionnaire(data = "./data/kri_winter.csv",
questions.file = "./data/questions_kri_winter.csv",
choices.file = "./data/choices_kri_winter.csv",
choices.label.column.to.use = "english")
# percent of questions successfully matched:
(length(questionnaire$questions$name %>% hasdata)/length(questionnaire$questions$name)*100) %>% round %>% paste0("% questions matched") %>% cat
#this warning needs to be integrated in load_questionnaire
if("weights" %in% names(data)){stop("'weights' is not allowed as a column name (will be calculated from the sampling frame)")}
dependent.var = "modality"
if(nrow(data)==0){stop('dependent var is all NA')}
independent.var = "idp.ref"
####################
# test what becomes analyse_indicator() later:
####################
data <- data[!is.na(dependent.var),]
data <- data[!(dependent.var %in% c("NA", "N/A")),]
# select methods
variable_weights <- reachR:::weights_of(data)
design <- svydesign(ids =~1,
strata = data$group,
weights = variable_weights %>% as.vector,
data = data)
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
# map from input to analysis case:
case<- map_to_case(hypothesis.type = hypothesis.type,
data = data,
dependent.var = dependent.var,
independent.var = independent.var,
paired = NULL)
debug(analyse_indicator)
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
hypothesis.type
hypothesis.type
dependent.var = "modality"
if(nrow(data)==0){stop('dependent var is all NA')}
independent.var = "idp.ref"
hypothesis.type="group_difference"
hypothesis.type
dependent.var = "modality"
if(nrow(data)==0){stop('dependent var is all NA')}
independent.var = "idp.ref"
hypothesis.type="group_difference"
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
case
summarise.result
#################################
# map to hypothesis test  :     #
#################################
map_to_hypothesis_test(case)
debug(analyse_indicator)
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
case
map_to_hypothesis_test(case)
map_to_hypothesis_test(case)
#################################
# map to visualisation:         #
#################################
map_to_visualisation <- function(case) {
visualisation_functions<-list()
# prefill all valid cases with 'not implemented' errors:
visualisation_functions<-list()
visualisation_functions<-lapply(list_all_cases(implemented_only = F),function(x){
function(...){stop(paste("not implemented: visualisation for case",x,".\n the geneva data unit can help!"))}
})
names(visualisation_functions)<-list_all_cases(implemented_only = F)
# add implemented cases:
visualisation_functions[["CASE_group_difference_categorical_categorical"]] <- barchart_with_error_bars
return(visualisation_functions[[case]])
}
source("./scripts/dependencies.R")
source("./scripts/analyse_indicator.R")
source("./scripts/mappings.R")
source("./scripts/summary_statistics.R")
source("./scripts/hypothesis_tests.R")
source("./scripts/visualisations.R")
library(reachR)
#install.packages("bit64")
# library(bit64)
require(data.table)
require(survey)
options(survey.lonely.psu = "average")
run once
####################
# install.packages("data.table")
# .install_reachR(T, branch = "develop")
####################
source("./scripts/dependencies.R")
source("./scripts/analyse_indicator.R")
source("./scripts/mappings.R")
source("./scripts/summary_statistics.R")
source("./scripts/hypothesis_tests.R")
source("./scripts/visualisations.R")
library(reachR)
#install.packages("bit64")
# library(bit64)
require(data.table)
require(survey)
options(survey.lonely.psu = "average")
####################
undebug(analyse_indicator)
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
debug(analyse_indicator)
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
analyse_indicator<-function(data,
dependent.var,
independent.var = NULL,
hypothesis.type,
design,
do.for.each.unique.value.in.var = NULL){
# sanitise input
# data <- data[!is.na(data[,dependent.var]),]
if(nrow(data)==0){stop('provided data has no rows where dependent.var is not NA')}
if(all(is.na(data[,dependent.var]))){stop(paste('variable', dependent.var, 'can\'t be all NA'))}
# map from input to analysis case:
case<- map_to_case(hypothesis.type = hypothesis.type,
data = data,
dependent.var = dependent.var,
independent.var = independent.var,
paired = NULL)
# map from case to appropriate summary statistic, hypothesis test and visualisation:
summarise.result<- map_to_summary_statistic(case)
test.hypothesis <- map_to_hypothesis_test(case)
visualisation <- map_to_visualisation(case)
# apply the ummary statistic, hypothesis test to the given data and survey design:
summary.result  <- summarise.result(dependent.var,independent.var, design)
# do hypothesis test:
hypothesis.test.result<- test.hypothesis(dependent.var,independent.var, design)
# add results to the visualisation:
# visualisation<-visualisation+ggplot()...
return(list(
summary.result,
hypothesis.test.result,
visualisation
))
}
debug(analyse_indicator)
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
case
summarise.results
summarise.result
debug(summarise.result)
debug(analyse_indicator)
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
debug(summarise.result)
formula_string
data$modality
data[[independent.var]]
data[[independent.var]] %>% length
data[[dependent.var]] %>% length
data[[weights]] %>% length
svytable(formula(formula_string), design)
design$variables$weights<-weights_of(design$variables)
reachR:::weights_of(design$variables)
design$variables$weights<-reachR:::weights_of(design$variables)
design$variables %>% nrow
reachR:::weights_of(design$variables) %>% nrow
reachR:::weights_of(design$variables) %>% length
design$variables %>% str
design$strata %>% length
design$strata
data$group
reachR:::weights_of(data)
populations <-load_samplingframe("./data/kri_winter_weights.csv",
sampling.frame.population.column="population",
sampling.frame.stratum.column = "group",
data.stratum.column = "group", return.stratum.populations = T)
data$group %>% length
weights_of(data$group)
weights_of(data$group) %>% length
reachR:::weights_of(data$group) %>% length
reachR:::weights_of(data$group) %>% length
data$group
reachR:::weights_of(data) %>% length
# the cleaning checks will be hidden somewhere else, for now they live here
data <- load_data(file = "./data/kri_winter.csv")
# the cleaning checks will be hidden somewhere else, for now they live here
data <- load_data(file = "./data/kri_winter.csv")
data <- data[data$group!="#N/A",]
populations <-load_samplingframe("./data/kri_winter_weights.csv",
sampling.frame.population.column="population",
sampling.frame.stratum.column = "group",
data.stratum.column = "group", return.stratum.populations = T)
questionnaire <- load_questionnaire(data = "./data/kri_winter.csv",
questions.file = "./data/questions_kri_winter.csv",
choices.file = "./data/choices_kri_winter.csv",
choices.label.column.to.use = "english")
# percent of questions successfully matched:
(length(questionnaire$questions$name %>% hasdata)/length(questionnaire$questions$name)*100) %>% round %>% paste0("% questions matched") %>% cat
#this warning needs to be integrated in load_questionnaire
if("weights" %in% names(data)){stop("'weights' is not allowed as a column name (will be calculated from the sampling frame)")}
dependent.var = "modality"
if(nrow(data)==0){stop('dependent var is all NA')}
independent.var = "idp.ref"
hypothesis.type="group_difference"
####################
# test what becomes analyse_indicator() later:
####################
data <- data[!is.na(dependent.var),]
data <- data[!(dependent.var %in% c("NA", "N/A")),]
reachR:::weights_of(data)
# select methods
variable_weights <- reachR:::weights_of(data)
design <- svydesign(ids =~1,
strata = data$group,
weights = variable_weights %>% as.vector,
data = data)
undebug(analyse_indicator)
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
undebug(percent_with_confints)
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
percent_with_confints <- function(independent.var = independent.var,
dependent.var = data.dependent.var,
design,
na.rm = TRUE){
formula_string<-paste0("~",independent.var, "+", dependent.var)
f.table <- svytable(formula(formula_string), design)
formula_err <- paste0("~", dependent.var, sep = "")
by <- paste0(" ~", independent.var, sep = "")
error_bars <- svyby(formula(formula_err), formula(by), design, na.rm = T, svymean)
names_df <- sapply(rownames(f.table), paste0, colnames(f.table))
results<-list()
results$names <- c(names_df[,1], names_df[,2])
results$numbers <- as.numeric(c(prop.table(f.table, 1)[1,], prop.table(f.table, 1)[2,]))
results$se <- as.numeric(c(error_bars[,grep("se.", names(error_bars))][1,], error_bars[,grep("se.", names(error_bars))][2,]))
results$min <- results$numbers - results$se
results$max <- results$numbers + results$se
return(results)
}
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
# confidence_intervals_num <- function(dependentvar, design, data = data){
#   summary <- svymean(data[[dependentvar]], design, na.rm = T)
#   confint(svymean(data[[dependentvar]] + data[[dependentvar]], design, na.rm = T), level = 0.95)
# }
#
percent_with_confints <- function(independent.var = independent.var,
dependent.var = data.dependent.var,
design,
na.rm = TRUE){
formula_string<-paste0("~",independent.var, "+", dependent.var)
f.table <- svytable(formula(formula_string), design)
formula_err <- paste0("~", dependent.var, sep = "")
by <- paste0(" ~", independent.var, sep = "")
error_bars <- svyby(formula(formula_err), formula(by), design, na.rm = T, svymean)
names_df <- sapply(rownames(f.table), paste0, colnames(f.table))
results<-list()
results$names <- c(names_df[,1], names_df[,2])
results$numbers <- as.numeric(c(prop.table(f.table, 1)[1,], prop.table(f.table, 1)[2,]))
results$se <- as.numeric(c(error_bars[,grep("se.", names(error_bars))][1,], error_bars[,grep("se.", names(error_bars))][2,]))
results$min <- results$numbers - results$se
results$max <- results$numbers + results$se
return(results)
}
# confidence_intervals_num <- function(dependentvar, design, data = data){
#   summary <- svymean(data[[dependentvar]], design, na.rm = T)
#   confint(svymean(data[[dependentvar]] + data[[dependentvar]], design, na.rm = T), level = 0.95)
# }
#
#
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
hypothesis_test_chisquared <- function(independent.var = independent.var,
dependent.var = data.dependent.var,
design){
formula_string<-paste0("~",independent.var, "+", dependent.var)
chisq <- svychisq (formula(formula_string), design, na.rm = TRUE)
results<-list()
results$test.results <- c(chisq$statistic, chisq$p.value)
results$test.parameters <- c(chisq$parameter, chisq$method)
results$hypothesis_test<-"chi-squared test of independence"
return(results)
}
hypothesis_test_chisquared <- function(independent.var = independent.var,
dependent.var = data.dependent.var,
design){
formula_string<-paste0("~",independent.var, "+", dependent.var)
chisq <- svychisq (formula(formula_string), design, na.rm = TRUE)
results<-list()
results$test.results <- c(chisq$statistic, chisq$p.value)
results$test.parameters <- c(chisq$parameter, chisq$method)
results$hypothesis_test<-"chi-squared test of independence"
return(results)
}
########ONE SAMPLE Z tEST
# hypothesis_test_one_sample_z_num <- function(data.dependent.var, crit, design, data = data) {
# doesn't seem right.. parameter 'crit' not used.
#   svyttest(data[[dependentvar]]~data[[independent.var]], design = design, family = quasibinomial())
# }
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
analyse_indicator<-function(data,
dependent.var,
independent.var = NULL,
hypothesis.type,
design,
do.for.each.unique.value.in.var = NULL){
# sanitise input
# data <- data[!is.na(data[,dependent.var]),]
if(nrow(data)==0){stop('provided data has no rows where dependent.var is not NA')}
if(all(is.na(data[,dependent.var]))){stop(paste('variable', dependent.var, 'can\'t be all NA'))}
# map from input to analysis case:
case<- map_to_case(hypothesis.type = hypothesis.type,
data = data,
dependent.var = dependent.var,
independent.var = independent.var,
paired = NULL)
# map from case to appropriate summary statistic, hypothesis test and visualisation:
summarise.result<- map_to_summary_statistic(case)
test.hypothesis <- map_to_hypothesis_test(case)
visualisation <- map_to_visualisation(case)
# apply the ummary statistic, hypothesis test to the given data and survey design:
summary.result  <- summarise.result(dependent.var,independent.var, design)
# do hypothesis test:
hypothesis.test.result<- test.hypothesis(dependent.var,independent.var, design)
# add results to the visualisation:
# visualisation<-visualisation+ggplot()...
return(list(
summary.statistic=summary.result,
hypothesis.test.result=hypothesis.test.result,
visualisation=visualisation
))
}
analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
results<-  analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
results$visualisation()
barchart_with_error_bars <- function(hypothesis.test.results,summary.statistics){
test_name <- hypothesis.test.results$test.parameters[[3]]
p_value <- hypothesis.test.results$test.results[[2]]
chart <- reach_style_barchart(group = summary.result$names,
percent = summary.result$numbers,
error_min = summary.result$min,
error_max =  summary.result$max)
chart + geom_text(aes(x =4,
y = 2,
label= paste0("To determine ", hypothesis.type, "\n", test_name, "\n"
," returned a p value of ", round(p_value,6))),
size=3,
family="Arial Narrow",
col='#000000',
hjust=0,
vjust=0.5)
}
results <-  analyse_indicator(data, dependent.var, independent.var, hypothesis.type, design)
results$visualisation()
results$visualisation(results$hypothesis.test.result,results$summary.statistic)
