# unload devtools
detach("package:devtools", unload=TRUE)
if(reinstall_if_exists){
warning("Please restart R session to update reachR documentation")
}
}
}
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
require(dplyr)
library(reachR)
require(survey)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# load input
data<-read.csv2(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv",header = T,stringsAsFactors = F)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
data.dependent.var = "resp_gender"
independent.var = "settlement"
hypothesis.type="difference_in_groups"
#das könnte auch eleganter gehen mit funktion über x und jeder variable in x einen Type dazu machen
find.data.types <- function(data.dependent.var, independent.var = NULL) {
if(question_is_categorical(data.dependent.var) == T){
data.type.dep = "categorical"
}
if(question_is_numeric(data.dependent.var) == T){
data.type.dep = "numeric"
}
if(question_is_categorical(independent.var) == T){
data.type.indep = "categorical"
}
if(question_is_numeric(independent.var) == T){
data.type.indep = "numeric"
}
variable.types <- paste(data.type.dep, data.type.indep, sep="_")
return(variable.types)
}
find.data.types(data.dependent.var, independent.var)
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T)
rm(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
require(dplyr)
library(reachR)
require(survey)
getwd()
# load input
data<-read.csv2(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv",header = T,stringsAsFactors = F)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
reachR:::load_questionnaire
data.dependent.var = "resp_gender"
independent.var = "settlement"
hypothesis.type="difference_in_groups"
#das könnte auch eleganter gehen mit funktion über x und jeder variable in x einen Type dazu machen
find.data.types <- function(data.dependent.var, independent.var = NULL) {
if(question_is_categorical(data.dependent.var) == T){
data.type.dep = "categorical"
}
if(question_is_numeric(data.dependent.var) == T){
data.type.dep = "numeric"
}
if(question_is_categorical(independent.var) == T){
data.type.indep = "categorical"
}
if(question_is_numeric(independent.var) == T){
data.type.indep = "numeric"
}
variable.types <- paste(data.type.dep, data.type.indep, sep="_")
return(variable.types)
}
find.data.types(data.dependent.var, independent.var)
data.dependent.var
independent.var
question_is_numeric(data.dependent.var)
question_is_categorical(independent.var)
question_is_numeric(independent.var)
question_is_numeric(independent.var) %>% print
question_is_numeric
question_is_numeric(independent.var) %>% print
question_is_numeric
reachR:::question_is_numeric_internal(independent.var) %>% print
debug(reachR:::question_is_numeric_internal)
reachR:::question_is_numeric_internal(independent.var) %>% print
qid
grep("integer", questions$type[qid])
grep("decimal",
questions$typep[qid])
length(c(grep("integer", questions$type[qid]), grep("decimal",
questions$typep[qid])))
(length(c(grep("integer", questions$type[qid]), grep("decimal",
questions$typep[qid]))) > 0)
undebug(reachR:::question_is_numeric_internal)
if(!require(devtools)) install.packages("devtools")
install.packages("ggpubr")
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T)
.install_reachR<-function(reinstall_if_exists = F){
if(!.is.package.installed("reachR") | reinstall_if_exists){
# get devtools if needed
if(!.is.package.installed("devtools")){install.packages("devtools")}
require("devtools")
install_github("mabafaba/reachR",ref = "master", auth_token = "dda123a51bd8fc6c2d0c47208ba6df17abee8b82")
# unload devtools
detach("package:devtools", unload=TRUE)
if(reinstall_if_exists){
warning("Please restart R session to update reachR documentation")
}
}
}
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#das könnte auch eleganter gehen mit funktion über x und jeder variable in x einen Type dazu machen
find.data.types <- function(data.dependent.var, independent.var = NULL) {
if(question_is_categorical(data.dependent.var) == T){
data.type.dep = "categorical"
}
if(question_is_numeric(data.dependent.var) == T){
data.type.dep = "numeric"
}
if(question_is_categorical(independent.var) == T){
data.type.indep = "categorical"
}
if(question_is_numeric(independent.var) == T){
data.type.indep = "numeric"
}
variable.types <- paste(data.type.dep, data.type.indep, sep="_")
return(variable.types)
}
find.data.types(data.dependent.var, independent.var)
library(reachR)
require(survey)
getwd()
#das könnte auch eleganter gehen mit funktion über x und jeder variable in x einen Type dazu machen
find.data.types <- function(data.dependent.var, independent.var = NULL) {
if(question_is_categorical(data.dependent.var) == T){
data.type.dep = "categorical"
}
if(question_is_numeric(data.dependent.var) == T){
data.type.dep = "numeric"
}
if(question_is_categorical(independent.var) == T){
data.type.indep = "categorical"
}
if(question_is_numeric(independent.var) == T){
data.type.indep = "numeric"
}
variable.types <- paste(data.type.dep, data.type.indep, sep="_")
return(variable.types)
}
find.data.types(data.dependent.var, independent.var)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
rm(list = ls())
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T)
# load input
data<-read.csv2(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv",header = T,stringsAsFactors = F)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T)
# load input
data<-read.csv2(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv",header = T,stringsAsFactors = F)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
load_samplingframe
rm(list = ls())
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T)
require(dplyr)
library(reachR)
require(survey)
load_samplingframe
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
library(reachR)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
debug(load_questionnaire)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
read.csv2("./questionscomma2.csv")
hi <- read.csv2("./questionscomma2.csv")
View(questionnaire)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
hi <- read.csv2("./questionscomma2.csv")
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
hi <- read.csv2("./choices.csv")
hi <- read.csv2("./choices.csv")
hi <- read.csv2("./choices.csv")
hi <- read.csv2("./choices.csv")
undebug(load_questionnaire)
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
hi <- read.csv2("./choices.csv")
hi <- read.csv2("./choices.csv")
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
require(dplyr)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
#das könnte auch eleganter gehen mit funktion über x und jeder variable in x einen Type dazu machen
find.data.types <- function(data.dependent.var, independent.var = NULL) {
if(question_is_categorical(data.dependent.var) == T){
data.type.dep = "categorical"
}
if(question_is_numeric(data.dependent.var) == T){
data.type.dep = "numeric"
}
if(question_is_categorical(independent.var) == T){
data.type.indep = "categorical"
}
if(question_is_numeric(independent.var) == T){
data.type.indep = "numeric"
}
variable.types <- paste(data.type.dep, data.type.indep, sep="_")
return(variable.types)
}
find.data.types(data.dependent.var, independent.var)
find.data.types(data.dependent.var, independent.var)
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
require(dplyr)
library(reachR)
require(survey)
getwd()
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
#load sampling frame
samplingframe<-read.csv2(file = "sf.csv",header = T,stringsAsFactors = F)
# load input
data<-read.csv2(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv",header = T,stringsAsFactors = F)
#load sampling frame
samplingframe<-read.csv(file = "sf.csv",header = T,stringsAsFactors = F)
# load input
data<-read.csv2(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv",header = T,stringsAsFactors = F)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
.install_reachR<-function(reinstall_if_exists = F){
if(!.is.package.installed("reachR") | reinstall_if_exists){
# get devtools if needed
if(!.is.package.installed("devtools")){install.packages("devtools")}
require("devtools")
install_github("mabafaba/reachR",ref = "master", auth_token = "dda123a51bd8fc6c2d0c47208ba6df17abee8b82")
# unload devtools
detach("package:devtools", unload=TRUE)
if(reinstall_if_exists){
warning("Please restart R session to update reachR documentation")
}
}
}
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T)
# load input
data<-read.csv2(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv",header = T,stringsAsFactors = F)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
# load input
data<-read.csv2(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv",header = T,stringsAsFactors = F)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
require(dplyr)
library(reachR)
require(survey)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
rm(hi)
#' load_questionnaire
#'
#' @param questions.file file name of a csv file containing the kobo form's question sheet
#' @param choices.file file name of a csv file containing the kobo form's choices sheet
#' @return list of questions and choices, sorted to match. to data columns.
#' @seealso \code{\link{load_data()}, \link{load_samplingframe}}
#' @export
#' @examples
#'
load_questionnaire<-function(data,
questions.file,
choices.file,
choices.label.column.to.use="label..English"){
# generic function to replace values in a vector based on a lookup table
replace_with_lookup_table<-function(x,y){
x2 <- y[match(x, y[,1]),2]
dim(x2) <- dim(x)
x2
}
# load files
questions<-read.csv2(questions.file,stringsAsFactors = F, header = T)
choices<-read.csv2(choices.file,stringsAsFactors = F, header = T)
# harmonise data column references
questions$name <- reachR:::to_alphanumeric_lowercase(questions$name)
names(choices) <- reachR:::to_alphanumeric_lowercase(names(choices))
names(data) <- reachR:::to_alphanumeric_lowercase(names(data))
choices.label.column.to.use <- reachR:::to_alphanumeric_lowercase(choices.label.column.to.use)
# sanitise
names(questions)
reachR:::insure.string.is.column.header(questions, "type")
reachR:::insure.string.is.column.header(questions, "name")
reachR:::insure.string.is.column.header(choices, choices.label.column.to.use)
reachR:::insure.string.is.column.header(choices, "list.name")
# get data column names
data_colnames<-names(data); data_colnames
# this changes the questionnaire questions and choices to fit the data columns, with empty entries for data columns that don't appear in the questionnaire.
questions<- questions[match(data_colnames, questions$name),]
choices_per_data_column<-questions$type %>% as.character %>% strsplit(" ") %>% lapply(unlist)%>% lapply(function(x){
x %>% lapply(function(y){
grep(y,choices$list_name,value=F)
}
) %>% unlist
}) %>% lapply(hasdata) %>% lapply(function(x){
choices[x,]
})
names(choices_per_data_column)<- data_colnames
# make functions that need questionnaire
assignInNamespace(x = "question_get_choice_labels_internal", ns="reachR", value = function(responses,variable.name){
labels<-replace_with_lookup_table(
responses,
# MAKE LABEL COLUMN A PARAMETER!!!
cbind(as.character(choices_per_data_column[[variable.name]]$name),as.character(choices_per_data_column[[variable.name]]$label..datamerge))
)
# fix those that were not found to go back to original NA
labels[is.na(labels)]<-responses[is.na(labels)]
labels
})
assignInNamespace(x = "question_is_numeric_internal", ns="reachR", value =function(question.name){
qid<-which(questions$name==question.name)
if(length(qid)==0){return(FALSE)}
if(length(c(grep("integer",questions$type[qid]),grep("decimal"),questions$typep[qid]))>0){return(TRUE)}
return(FALSE)
})
assignInNamespace(x = "question_is_select_one_internal", ns="reachR", value =function(question.name){
if(!(question.name %in% questions$name)){return(FALSE)}
qid<-which(questions$name==question.name)
if(length(grep("select_one",questions$type[qid]))>0){return(TRUE)}
return(FALSE)
})
assignInNamespace(x = "question_is_select_multiple_internal", ns="reachR", value = function(question.name){
if(!(question.name %in% questions$name)){return(FALSE)}
qid<-which(questions$name==question.name)
if(length(grep("select_multiple",questions$type[qid]))>0){return(TRUE)}
return(FALSE)
})
assignInNamespace(x = "question_is_categorical_internal", ns="reachR", value = function(question.name){
return(question_is_select_one(question.name) | question_is_select_multiple(question.name))
})
message("you can now use \n 'get_choice_labels():'change answers to their labels \n question_is_categorical() \n question_is_categorical()\n question_is_select_one() \n question_is_select_multiple()")
return(list(questions=questions,choices=choices,choices_per_variable=choices_per_data_column))
}
question_get_choice_labels_internal<-function(responses,variable.name){
stop("you must successfully run load_questionnaire() first")
}
question_is_numeric_internal<-function(question.name){
stop("you must successfully run load_questionnaire() first")
}
question_is_select_one_internal<-function(question.name){
stop("you must successfully run load_questionnaire() first")
}
question_is_select_multiple_internal<-function(question.name){
stop("you must successfully run load_questionnaire() first")
}
question_is_categorical_internal<-function(question.name){
stop("you must successfully run load_questionnaire() first")
}
#' question_get_choice_labels
#'
#' @param responses a vector of responses
#' @param variable.name the column name of the corresponding variable
#' @return vector of labels corresponding to the responses vector. If no corresponding label is found, return the original value
#' @seealso
#' @export
#' @examples
#'
question_get_choice_labels<-function(responses,variable.name){
question_get_choice_labels_internal(responses,variable.name)
}
#' question_is_numeric
#'
#' @param question.name the name of a data column header
#' @return TRUE if the question is of type integer or decimal
#' @seealso
#' @export
#' @examples
#'
question_is_numeric<-function(question.name){
question_is_numeric_internal(question.name)
}
#' question_is_select_one
#'
#' @param question.name the name of a data column header
#' @return TRUE if the question is of type select_one
#' @seealso
#' @export
#' @examples
#'
question_is_select_one<-function(question.name){
question_is_select_one_internal(question.name)
}
#' question_is_select_multiple
#'
#' @param question.name the name of a data column header
#' @return TRUE if the question is of type select_multiple
#' @seealso
#' @export
#' @examples
#'
question_is_select_multiple<-function(question.name){
question_is_select_multiple_internal(question.name)
}
#' question_is_categorical
#'
#' @param question.name the name of a data column header
#' @return TRUE if the question is of type select_one or select_multiple
#' @seealso
#' @export
#' @examples
#'
question_is_categorical<-function(question.name){
question_is_categorical_internal(question.name)
}
require(dplyr)
library(reachR)
require(survey)
# load input
data<-read.csv2(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv",header = T,stringsAsFactors = F)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
#das könnte auch eleganter gehen mit funktion über x und jeder variable in x einen Type dazu machen
find.data.types <- function(data.dependent.var, independent.var = NULL) {
if(question_is_categorical(data.dependent.var) == T){
data.type.dep = "categorical"
}
if(question_is_numeric(data.dependent.var) == T){
data.type.dep = "numeric"
}
if(question_is_categorical(independent.var) == T){
data.type.indep = "categorical"
}
if(question_is_numeric(independent.var) == T){
data.type.indep = "numeric"
}
variable.types <- paste(data.type.dep, data.type.indep, sep="_")
return(variable.types)
}
find.data.types(data.dependent.var, independent.var)
# load input
read.csv.auto.sep<-function(file){
L<-readLines(file, n = 1)
numfields <- count.fields(textConnection(L), sep = ";")
if (numfields == 1) read.csv(file) else read.csv2(file)
}
data<-read.csv.auto.sep(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv",header = T,stringsAsFactors = F)
data<-read.csv.auto.sep(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv")
file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv"
L<-readLines(file, n = 1)
L
numfields <- count.fields(textConnection(L), sep = ";")
numfields
textConnection
textConnection(L)
count.fields(textConnection(L), sep = ";")
L
numfields<- L %>% strsplit(";") %>% length
numfields
L %>% strsplit(";")
numfields<- L %>% strsplit(";") %>% unlist %>% length
numfields
# make sure this works again when you start the next day (don't assume commands from other files have been run), e.g this one
# set wd to this script's folder
.install_reachR(T)
require(dplyr)
library(reachR)
require(survey)
# load input
read.csv.auto.sep<-function(file){
L<-readLines(file, n = 1)
numfields<- L %>% strsplit(";") %>% unlist %>% length
if (numfields == 1) read.csv(file) else read.csv2(file)
}
data<-read.csv.auto.sep(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv")
require(dplyr)
# load input
read.csv.auto.sep<-function(file){
L<-readLines(file, n = 1)
numfields<- L %>% strsplit(";") %>% unlist %>% length
if (numfields == 1) read.csv(file) else read.csv2(file)
}
data<-read.csv.auto.sep(file = "./reach_som_protection_assessment_hh_cleaneddata_feb_2018.csv")
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
debug(load_questionnaire)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
debug(load_questionnaire)
#load questionnaire
questionnaire <- load_questionnaire(data, questions.file = "./questionscomma2.csv", choices.file = "./choices.csv", choices.label.column.to.use = "english")
match.fun
